# Soft assignment of data to cluster.

import numpy as np
import pandas as pd
from sklearn.datasets import make_blobs
import matplotlib.pyplot as plt
import seaborn as sns 
from sklearn.mixture import BayesianGaussianMixture
from scipy.stats import chi2
from matplotlib.patches import Ellipse

# --- Data Generation & DPMM Fitting ---
data_1, _ = make_blobs(n_samples=500, centers=[[10, 5], [15, 8], [8, 12]], cluster_std=[1.5, 1.2, 1.0], random_state=42)
data_2, _ = make_blobs(n_samples=100, centers=[[20, 15], [5, 5]], cluster_std=[0.5, 0.7], random_state=1)
X = np.vstack((data_1, data_2))
df = pd.DataFrame(X, columns=['Luminosity (L)', 'Color Index (C)'])

# DPGMM setup: Uses DP prior to automatically find the number of clusters
dpmm = BayesianGaussianMixture(
    n_components=10, 
    covariance_type='full', 
    weight_concentration_prior_type='dirichlet_process', 
    max_iter=500, 
    random_state=42
)
dpmm.fit(df) # Training determines the cluster centers and weights

# --- CRITICAL STEP: SOFT ASSIGNMENT ---
# Get the soft assignments (a matrix of probabilities, shape (n_samples, n_components))
soft_probabilities = dpmm.predict_proba(df)

# --- Analysis & Ellipse Setup ---
active_clusters_mask = dpmm.weights_ > 0.01
component_means = dpmm.means_[active_clusters_mask]
component_covariances = dpmm.covariances_[active_clusters_mask]

# Filter the probabilities to include only the active clusters
# The columns correspond to the indices in active_clusters_mask
soft_probs_active = soft_probabilities[:, active_clusters_mask]

# Color Synchronization
full_seaborn_palette = sns.color_palette('deep', n_colors=10)
all_indices = np.arange(dpmm.n_components)
active_component_ids = all_indices[active_clusters_mask]

# --- Ellipse Function (Unchanged) ---
def plot_gaussian_ellipse(ax, mean, covariance, color, z=2):
    scale_factor = np.sqrt(chi2.ppf(0.95, 2))
    lambda_, v = np.linalg.eigh(covariance)
    lambda_ = np.sqrt(lambda_)
    angle = np.degrees(np.arctan2(*v[:, 0][::-1]))
    
    ellipse = Ellipse(
        xy=mean,
        width=lambda_[0] * scale_factor,
        height=lambda_[1] * scale_factor,
        angle=angle,
        color=color,
        alpha=0.3,
        linestyle='--',
        linewidth=4,
        fill=False
    )
    ax.add_patch(ellipse)

# --- PLOTTING (Soft Assignment) ---
fig, ax = plt.subplots(figsize=(10, 7))

# 1. Plot the ellipses first for context (remains unchanged)
for i, (mean, cov) in enumerate(zip(component_means, component_covariances)):
    cluster_id = active_component_ids[i]
    ellipse_color = full_seaborn_palette[cluster_id]

    # Correct Axis Handling: (x=C, y=L)
    center = (mean[1], mean[0]) 
    new_cov = cov[::-1, ::-1]   
    
    plot_gaussian_ellipse(ax, center, new_cov, ellipse_color)

# 2. Scatter Plot using Matplotlib for SOFT ASSIGNMENT
# Iterate over each active cluster and plot ALL data points
for i, cluster_id in enumerate(active_component_ids):
    # Get the probability vector for the current active cluster
    probs = soft_probs_active[:, i]
    
    # Get the fixed color for the current cluster
    cluster_color = full_seaborn_palette[cluster_id]

    # Plot an invisible, fully opaque point for the legend ---
    # We use a single point (x=0, y=0, fully opaque alpha=1.0) with a label.
    # The 's=0' makes the point itself invisible, but its label is captured 
    # for the legend.
    ax.scatter(
        x=[], 
        y=[], 
        color=cluster_color, 
        alpha=1.0,  # CRITICAL: Use full opacity (1.0) for the legend marker
        s=50,       
        label=f'Population ID {cluster_id}' # This label will appear in the legend
    )

    # --- Data Plot: Plot the full dataset with variable opacity, NO label ---
    # The data points should NOT have a label so they don't interfere 
    # with the legend created above.
    ax.scatter(
        x=df['Color Index (C)'],
        y=df['Luminosity (L)'],
        color=cluster_color, 
        alpha=probs,        # Alpha (opacity) value for each point is its probability
        s=50,
        label='_nolegend_' # Matplotlib convention to exclude from legend
    )

# 3. Final Touches
ax.set_title('DPGMM: Soft Assignment Visualization (Opacity = Probability)')
ax.set_xlabel('Color Index (C)')
ax.set_ylabel('Luminosity (L)')

# The legend generated by the scatter calls will work here
ax.legend(title='Population ID', loc='best')

plt.show()